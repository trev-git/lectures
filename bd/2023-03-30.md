(данные изменены), ещё незавершившийся транзакции, которая после будет отменена.

3. Проблема неповторяемого чтения

  При повторном чтении данных уже считанных ранее, транзакция обнаруживает модификации или удаление, вызванной другой завершённой транзакцией. (подобное изменение может нарушить логику работы транзакции)

4. Проблема чтения строк

Появляется когда при повторном чтении данных транзакция обнаруживает новые строки, вставленные или изменённые другой транзакцией, завершённой после предыдущего чтения этого набора данных

Пример 1

Пусть БД содержит информацию о товарах в магазине игрушек. Перед началом рассматриваемых параллельных транзакций в торговом зале находилось 10 красных мячиков. Пользователь А (продавец) вносит информацию о продаже пяти таких мячиков. Пользователь Б (работник склада) о доставке в торговый зал ещё двух мячей. Проблема заключается в том, что задания поступили одновременно и СУБД вынуждена обеспечивать их псевдопараллельное выполнение.

| Транзакция А | Транзакция Б |
| --- | --- |
| A1. Считать информацию о количестве красных мячиков (Результат: 10)| B1. Считать информацию о количестве красных мячиков (Результат: 10) |
| A2. Уменьшить количество на 5 (Результат: 5) | |
| A3. Записать значение в БД (Результат: 5) | B2. Увеличить количество на 2 (Результат: 12) |
| | B3. Записать значение в БД (Результат: 12) |

Чтобы избежать подобных проблем, необходимо обеспечить изоляцию транзакций. Основное средство здесь - блокировка ресурсов. СУБД не даёт конкурирующим транзакциям копии одной и той же записи, когда предполагается её скорое изменение.

1. exclusive lock или x-lock
2. shared lock или s-lock - элемент становится недоступным для изменения, но его можно прочитать

В некоторых ситуациях может возникать ситуация взаимной блокировки, когда две транзакции блокируют работу другой, и ни одна из них не может продолжить выполнение, чтобы в результате снять блокировку.

Такие ситуации должны отслеживаться СУБД:

- Обычно одна из транзакций принудительно откатывается, а другая продолжает работу.

Пусть исходная таблица содержит данные о бронировании билетов на авиарейс

| Reis | Mesto | FIO |
| --- | --- | --- |
| 10 | 7B | NULL |
| 10 | 7C | NULL |
| ... | ... | ... |

Reserv

Пример привязанного чтения

Транзакция A обновляет данные в строке, после чего происходит откат транзакции. Из-за того, что между этими событиями транзакция Б прочитала данные из этой строки, было получено некорректное значение.

| Транзакция А | Транзакция Б |
| --- | --- |
| UPDATE Reserv SET FIO='Иванов И. И.' WHERE Reis = 10 AND Mesto = '7C'; | |
| ... | SELECT FIO FROM Reserv WHERE Reis = 10 AND Mesto = '7C' |
| ROLLBACK | |

Для решения перечисленных выше проблем в стандарте SQL92

Разработчик может указать желаемые сс сссс 