# Передача параметров через стек

Передачей параметров через регистры можно пользоваться, если параметров немного, в противном случае используют передачу параметров через стек: основная программа записывает фактические параметры в стек, а процедура их оттуда извлекает.

Пусть процедура P имеет k параметров. Перед обращением к процедуре основная программа записывает параметры в стек слева направо (сначала первый, потом второй...)

```x86asm
push a_1
push a_2
push a_k
call P
```

Чтобы при работе процедуры ей были доступны параметры, в регистр bp засылается адрес вершины стека (содержимое регистра `sp`), а затем используется выражение вида `[bp+i]`. Чтобы при этом не портить регистр `bp`, который может использоваться в основной программе, его сначала сохраняют, и только потом в него пересылают значение `sp`.

Таким образом, выполнение процедуры должно начинаться со следующих команд, называемых входными действиями процедуры.

```x86asm
P PROC
push bp    ; входные
mov bp, sp ; действия

; тело процедуры

P ENDP
```

После записи в стек старого значения bp для доступа к параметрам процедуры надо использовать выражение `[bp + длина адреса возврата + длина BP]` для доступа к последнему параметру.

`[bp + длина адреса возврата + длина BP + длина параметра a_k]` для доступа к предпоследнему параметру.

После завершения работы процедуры надо выполнить выходные действия. К этому моменту стек должен быть в том же состоянии, в каком он был после входных действий (если это не так, то можно восстановить данное состояние с помощью `mov sp, bp`). Тогда в вершине стека находится старое значение bp. Его считывают и восстанавливают bp. Теперь надо очистить стек от параметров и передать управление по адресу возврата. Это можно выполнить при помощи команды `ret число без знака`. По этой команде удаляется адрес возврата, затем стек очищается на указанное операндом число <u>байтов</u>. Выполняется переход по адресу возврата.

Обнулить массив X из ста байтов.

```x86asm
N equ 100
X db N dup(?)

lea ax, x
push ax
mov ax, N
push ax
call NULL

NULL PROC
push bp
mov bp, sp

push bx
push cx

mov cx, [bp+4]
mov bx, [bp+6]
NULLL1: mov byte ptr [bx], 0
inc bx
loop NULLL1

pop cx
pop bx

pop bp
ret 4
NULL ENDP
```

g = a+2b+3c+4d+5e+6f

```x86asm
a dw ...
b dw ...
c dw ...
d dw ...
e dw ...
f dw ...
g dw ?

push a
push b
push c
push d
push e
push f
call SUM
mov g, ax

SUM PROC
push rbp
mov rbp, rsp

push bx

mov ax, [rbp+26] # a

mov bx, [rbp+24]
shl bx, 1
add ax, bx # a + 2b

mov bx, [rbp+22] # c
shl bx, 1        # 2c
add bx, [rbp+22] # 3c
add ax, bx       # a+2b+3c

mov bx, [rbp+20] # d
shl bx, 2
add ax, bx       # a+2b+3c+4d

mov bx, [rbp+18] # e
shl bx, 2
add bx, [rbp+18]
add ax, bx       # a+2b+3c+4d+5e

mov bx, [rbp+16]
shl bx, 2
add bx, [rbp+16]
add bx, [rbp+16]
add ax, bx

pop bx

pop rbp
ret 12
SUM ENDP
```
