# Команды сдвига

## Логические сдвиги

```x86asm
SHL оп1, оп2 ; сдвиг оп1 на оп2 бит влево, оп1 := оп1 << оп2
SHR оп1, оп2 ; сдвиг оп1 на оп2 бит вправо, оп1 := оп1 >> оп2
```

$5a+\frac{1}{2}b=4a+a+\frac{1}{2}b = 2^2a+a+\frac{b}{2}$

```x86asm
A db ...
B db ...

mov al, a
mov bl, al
shl al, 2
add al, bl
mov bl, b
shr bl, 1
add al, bl
```

## Арифметические сдвиги

```x86asm
SAL оп1, оп2 ; арифметический сдвиг оп1 на оп2 бит влево
SAR оп1, оп2 ; арифметический сдвиг оп1 на оп2 бит вправо
```

SAL и SHL - одинаковые

Все биты первого операнда сдвигаются вправо; бит, уходящий за пределы ячейки, заносится в CF, знаковый (самый левый бит) восстанавливает своё искомое значение.

```x86asm
MOV BH, 1000 1110b
SAR BH, 1
; BH = 1000 0111b, CF = 0
MOV BH, 0000 1110b
SAR BH, 1
; BH = 0000 0111b, CF = 0
```

Команда арифметического сдвига используется для быстрого умножения и деления знаковых чисел на степень двойки.

# Циклические сдвиги

При циклических сдвигах бит, уходящий за пределы ячейки, возвращается в операнд с другого конца.

```x86asm
ROL оп1, оп2
ROR оп1, оп2
```

При сдвиге бит, уходящий за пределы ячейки, заносится в CF и в операнд с другого конца.

```x86asm
MOV CL, 1100 0011b
ROL CL, 1
; CL = 1000 0111b, CF = 1
MOV BH, 1110 0010b
ROR BH, 1
; BH = 0111 0001b, CF = 0
```

Команды циклического сдвига можно использовать для перестановки частей содержимого ячейки или регистра

```x86asm
MOV AL, 17h ; AL = 0001 0111b
ROL AL, 4
; AL = 01110001b, CF = 1
```

## Циклический сдвиг с переносом

```x86asm
RCL
RCR
jo ; biden
```

При сдвиге бит, уходящий за пределы ячейки, заносится во флаг CF, а прежнее значение флага заносится в операнд с другой стороны.

```x86asm
MOV BL, 1111 0000b
RCL BL, 1
; CF = 1, BL = 11100000b
RCL BL, 1
; CF = 1, BL = 11000001b
```

Команды циклического сдвига через перенос можно использовать при переносе битов из одного регистра или переменной в другой.

```x86asm
mov cx, 3
L: shl dh, 1
rcl al, 1
loop L
; 1) dh = bcdefgh0, cf = a
;    CF = i, al = jklmnopa
; 2) dh = cdefgh00, cf = b
;    CF = j, al = klmnopab
; 3) dh = defgh000, cf = c
;    CF = k, al = lmnopabc
```

Значение dh и al сдвигаются на три бита влево, справа к al приписывают три левых бита dh

# Упакованные данные

Программу пишут на языке ассемблера, когда надо получить программу, экономно расходующую память. Один из способов экономии памяти - использование упакованных данных, когда в ячейках располагают по несколько величин и размещение ведётся на уровне битов.

Y M D
$$
Y\le99<128=2^7 \\
M\le12<16=2^4 \\
D\le31<32=2^5 \\
$$

Так как содержимое ячейки можно записывать или считывать только целиком, то при работе с упакованными данными возникают проблемы - как выделить часть содержимого ячейки, как составить содержимое ячейки в виде отдельных частей

## Выделение части машинного слова

Выделение части ячейки - оставление только нужных битов ячейки и обнуление других. Выделение части ячейки реализуется использованием команды `AND`, а именно содержимое ячейки умножается на значение, содержащей единицу в соответствующих выделяемым разрядам, и ноль в остальных. Такое значение, используемое для выделения какой-либо части ячейки называется маской.

```x86asm
X | A | B | C |
    2   3   3
    00 111  000
```

```x86asm
X | A | B | C |
    2   3   3
Проверить, равна ли часть B пяти.

X db ...

mov al, X
and al, 00111000b
cmp al, 00101000b
je YES
NO:
```

Ячейка составляется из отдельных частей при помощи команды OR.

```x86asm
   233
X1 A0C
X2 0B0
------
 X ABC

Дано X1, A111C, X2 - 0B0

X db ?

mov al, x1
and al, 11000111b
or al, x2
mov x, al
```