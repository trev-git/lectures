# Тестирование

Это тестирование называют также тестированием по маршрутам, т.к. в этом случае тестовые наборы формируют путём анализа маршрутов, предусмотренных алгоритмом.

Под маршрутами в этом случае понимают последовательности операторов программы, которые выполняются при конкретном варианте исходных данных.

В основе структурного тестирования лежит концепция максимального полного тестирования всех маршрутов программы.

Структурный подход к тестированию имеет недостатки:

- не обнаруживаются пропущенные маршруты.
- не обнаруживают ошибок, зависящих от обрабатываемых данных, например в операторе if, то пропуск абсолютного значения функции `abs()` проявится, только если a < b. Не даются гарантии, что программа правильная, например, если вместо сортировки по убыванию сделало сортировку по возрастанию.

Формирование тестовых наборов для тестирования маршрутов может осуществляться по нескольким критериям:

- покрытие операторов
- покрытие решений (переходов)
- покрытие условий
- покрытие решений/условий
- комбинаторное покрытие условий

## Покрытие операторов

Этот критерий подразумевает такой подбор тестов, чтобы каждый оператор программы выполнялся по крайней мере один раз. Это необходимое, но недостаточное условие для приемлемого тестирования.

Чтобы все операторы программы были выполнены хотя бы один раз для проверки программы этого явно недостаточно.

## Покрытие решений или переходов

Для реализации этого критерия необходимо такое количество и состав тестов, чтобы результат проверки каждого условия принимало значение истина или ложь по крайней мере один раз. Критерий покрытия решений удовлетворяет критерию покрытия операторов но является более сильным.

Программа, алгоритм которой представлен на рисунке, можно протестировать по этому методу двумя тестами, либо покрывающими пути 1-2-4-6, либо 1-2-3-4-5-6 либо по пути 1-2-3-4-6 либо 1-2-4-5-6.

## Покрытие условий

Он является ещё более сильным по сравнению с предыдущими. В этом случае формируют некоторое количество тестов, достаточное для того, чтобы всевозможные результаты каждого условия в решении были выполнены хотя бы один раз.

Программа с этим алгоритмом проверяет 4 условия: a>1, b=0, a=2, x>1. Необходимо реализовать все возможные ситуации. Тесты, удовлетворяющие этому условию.

- 1 условие - да
- 2 условие - да
- 3 условие - да
- 4 условие - да

- 1 условие - нет
- 2 условие - нет
- 3 условие - нет
- 4 условие - нет

Основной недостаток этого критерия - недостаточная чувствительность к ошибкам логики.

## Покрытие решений/условий

По этому методу тесты должны составляться так, чтобы по крайней мере один раз выполнились всевозможные результаты каждого условия и все результаты каждого решения и каждому оператору управление передавалось хотя бы один раз.

Этому критерию удовлетворяют следующие тесты:
a=2 b=0 x=4 1-2-3-4-5-6

a=1 b=1 x=1 1-2-4-6

## Комбинаторное покрытие условий

Этот критерий требует создания такого множества тестов, чтобы все возможные комбинации результатов условий в каждом решении и все операторы выполнялись по крайней мере один раз. Для нашего алгоритма необходимо покрыть 8 комбинаций.

- a>1 b=0
- a>1 b!=0
- a<=1 b=0
- a<=1 b!=0
- a=2 x>1
- a=2 x<=1
- a!=2 x>1
- a!=2 x<=1

Эти комбинации можно проверить 4 тестами.

a=2 b=0 x=4 проверяют 1 и 5 комбинацию. \
a=2 b=1 x=1 проверяет 2 и 6 комбинацию. \
a=1 b=0 x=2 проверяет 3 и 7 комбинацию. \
a=1 b=1 x=1 проверяет 4 и 8 комбинацию.

## Функциональное тестирование

Это один из способов проверки программы с управлением по данным. В этом случае программа рассматривается как чёрный ящик и целью тестирования является выяснение обстоятельств. 

При функциональном тестировании различают следующие методы формирования тестовых наборов:

- эквивалентное разбиение
- анализ граничных значений
- анализ причинно-следственных связей
- предположение об ошибке

### Эквивалентное разбиение

Этот метод заключается в следующем: область всех возможных наборов входных данных программы по каждому параметру разбивают на конечное число групп, то есть классов-эквивалентов. Наборы данных такого класса объединяют по принципу обнаружения одних и тех же ошибок. Если набор какого-либо класса обнаруживает некоторую ошибку, то предполагается, что все другие тесты этого класса эквивалентности тоже обнаружит эту ошибку и наоборот. Разработку тестов этим методом осуществляют в два этапа. На первом выделяют классы эквивалентности, а на втором формируют тесты. При выделении классов эквивалентности считают целесообразным в отдельные классы эквивалентности наборы, содержащие допустимые и недопустимые значения некоторого параметра. При этом существует ряд правил:

- Если некоторый параметр может принимать значение в интервале от 1 до 999, то выделяют один правильный класс 1 <= x <= 999 и два неправильных класса x < 1 и x > 999
- Если входное условие определяет диапазон значений порядкового типа, например в автомобиле могут ехать от 1 до 5 человек, то определяется один правильный класс эквивалентности и два неправильных.
- Если входное условие описывает ситуацию должно быть например первым символом идентификатора должна быть буква, то определяется один правильный класс эквивалентности и один неправильный.

Таким образом, классы эквивалентности выделяют перебирая ограничения, установленные для каждого входного значения в ТЗ или для уточнения спецификаций. Каждое ограничение разбивают на две или более групп, при этом используя специальные бланки - таблицы классов эквивалентности. Шапка - ограничения, правильные классы эквивалентности, неправильные классы эквивалентности.

Для правильных и неправильных классов тесы проектируют отдельно. При построении правильных тестов классов учитывают, что каждый тест должен проверять по возможности максимальное количество различных входных условий. Для каждого неправильного класса формируют свой тест. Граничные значения - это значения на границах классов эквивалентности входных значений или около них. В этих местах резко увеличивается возможность обнаружения ошибок. Граничные значения могут быть едва уловимыми и их определения иногда связаны с большими трудностями, что является недостатком этого метода. 

Оба описанных метода основаны на исследовании входных данных и они не позволяют проверять результаты, получаемые при различных сочетаниях данных. Для построения тестов, проверяющих сочетания данных, применяют методы, использующие булеву алгебру.

## Анализ причинно-следственных связей

Он позволяет системно выбирать высокорезультативные тесты, использует алгебру логики и оперирует причинами. Причиной в данном случае называют отдельное входное условие или класс эквивалентности. Следствием называют выходное действие или преобразование системы. Идея метода заключается в отнесении всех следствий к причинам, то есть в уточнении причинно-следственных связей.

Построение тестов осуществляют в несколько этапов: сначала спецификации разбивают на рабочие участки, стараясь по возможности выделять в отдельные таблицы независимые группы причинно-следственных связей, а затем спецификации определяют множество причин и следствий.

Далее, на основе анализа семантического (смыслового) содержания спецификации строят таблицу истинности, в которой каждой возможной комбинации причин ставится в соответствие следствие, а для обозначения безразличных состояний используют X, которое предполагает произвольное значение условия, при необходимости аналогично строится таблица истинности для класса эквивалентности