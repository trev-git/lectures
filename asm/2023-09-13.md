# Циклы

Для циклов с заранее заданным числом повторений, существуют команды, упрощающие реализацию таких циклов, и называемые командами управления циклов.

Если тело цикла надо выполнить n раз, то это можно реализовать так:

```x86asm
mov cx, 0

L: ...
   ... тело
   ... цикла
   inc cx
   cmp cx, N
   JNE L
```

```x86asm
mov cx, N
L: ...тело
   ...цикла
   dec cx
   cmp cx, 0
   jne L
```

## Управление циклом по счётчику (команда loop)

Действия команды:

1. Содержимое cx уменьшается на 1.
2. Если cx != 0, переход на метку.
3. 

```x86asm
loop метка
```

<u>При использовании команды `loop` в качестве счётчика цикла обязательно должен применяться регистр `cx`, при другом регистре `loop` применять нельзя.</u>

Так как `loop` ставится в конце цикла, то тело цикла обязательно выполнится хотя бы один раз, и для случаев, когда число повторений может быть нулевым, надо сделать обход цикла.

## Команды условного перехода, проверяющие значения `cx`
```x86
; N > 0
JCXZ метка
jump if
cx is
zero
```

Если cx = 0, переход на метку.

```x86asm
; N >= 0
mov cx, N
jcxz L1
L: ...тело
   ...цикла
   loop L
L1:
```

Пусть N - байтовая переменная, посчитать N! и записать в ax.

```x86asm
N db ...
; AX := N!

mov ax, 1
mov cl, N
mov ch, 0
jcxz F1
F: mul si
   inc si
   loop F
F1:
```

S = 2 + 4 + ...

n слагаемых

```x86asm
n db ...
S db ?

mov al, 0
mov bl, 2
mov cl, N
mov ch, 0
jcxz fin
L1: add al, bl
    add bl, 2
    loop L1
fin: mov S, al
```

S=100-4-7-10-13-...

n раз

```x86asm
n equ ...
S dw ?

mov ax, 100
mov bx, 4
mov cx, n
jcxz fin
L1: sub ax, bx
    add bx, 3
    loop L1
fin: mov S, ax
```

S = 1^2 + 2^2 + 3^2

n слагаемых

```x86asm
n equ ...
S dw ?

mov bx, 0
mov cx, n
jcxz fin
mov dl, 1
L1: mov al, dl
    mul dl
    add bx, ax
    inc dl
    loop L1
fin: mov S, bx
```
