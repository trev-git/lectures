# Вложенные циклы

Пусть k - байтовая переменная со значением от 1 до 18. Записать в регистр `al` количество двузначных десятичных чисел, сумма цифр которых равна k.

```c
int main(void)
{
  int k = 3;
  int ax = 0;
  for (int i = 1; i <= 9; i++)
  {
    for (int j = 0; j <= 9; j++)
    {
      if (i + j == k)
      {
        ax++;
      }
    }
  }
  return ax;
}
```

```x86asm
k db ...

mov al, 0

mov cx, 9 ; начальные
mov dh, 1 ; значения
L0: mov bx, cx ; сохранить значение cx, спасибо внутреннему циклу
mov cx, 10 ; начальные
mov dl, 0 ; значения внутреннего цикла
L1: mov ah, dh ; счётчик внутреннего
add ah, dl
cmp ah, k
jne L2
inc al
L2: inc dl ; это часть условия, не цикла
loop L1
mov cx, bx
inc DH
loop L0
```

# Массивы

Исполнительный (эффективный) адрес - адрес, с которым работает команда.

Способы записи адресов:

```
A - адресное выражение ; A = A
E[M] - Е любое выражение (адресное или константное), М - регистр-модификатор (bx, bp - используется при работе со стеком, si, di). ; A = E+[M]
E = 0, 0[M] = [M]
E[M1][M2] ; A = E + [M1] + [M2]
```

```x86asm
A db ...

ADD A[SI], 5
```

Замена адреса из команды на исполнительный адрес называется модификацией адреса. Модификация адреса заключается в представлении адреса в виде суммы двух слагаемых, одно из которых указывается в команде (это постоянная часть), а изменяемая часть в регистре.

Заполнить массив по правилу 1,2,3,4,5

N EQU 5

```x86asm
mov bx, 1
mov cx, n
mov si, 0
L: mov a[si], bx
inc bx
add si, 2
loop L
```

массив байтов 2,4,6,8

```x86asm
N equ 5
A db N DUP(?)

mov di, 0
mov al, 2
mov cx, N
L1: mov A[di], al
add al, 2
inc di
loop L1
```

Увеличить на 1 элементы массива слов.

```x86asm
N equ 5
A dw ...

mov di, 0
mov cx, N
L1: inc A[di]
add di, 2
loop L1
```

Найти сумму элементов массива байтов

```x86asm
N equ ...
Y db ...
S db ?

mov al, 0
mov di, 0
mov cx, N
L1: add al, A[di]
inc di
loop L1
mov S, al
```
